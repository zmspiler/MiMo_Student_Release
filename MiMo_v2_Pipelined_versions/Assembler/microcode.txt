#0. nop - Default, for when condition is not met SHOUDL ALWAYS BE SET TO 0TH INSTRUCTION
0: pcsel=pc

# 1. mov - Rd, Rs   Rd <- Rs
1: regsrc=op2 dwrite=1 pcsel=pc

# 2. mvn - Rd, Rs   Rd <- !Rs
2: op2sel=op2 rvrsOps=1 aluop=not regsrc=aluout dwrite=1 pcsel=pc

# 3. add - Rd, Rs, Rt   Rd <- Rs + Rt
3: op2sel=op2 aluop=add regsrc=aluout dwrite=1 pcsel=pc

# 4. sub - Rd, Rs, Rt   Rd <- Rs - Rt
4: op2sel=op2 aluop=sub regsrc=aluout dwrite=1 pcload=1 pcsel=pc addrsel=pc

# 5. rsb - Rd, Rs, Rt   Rd <- Rt - Rs
5: op2sel=op2 aluop=sub rvrsOps=1 regsrc=aluout dwrite=1 pcsel=pc

# 6. mul - Rd, Rs, Rt   Rd <- Rs * Rt
6: op2sel=op2 aluop=mul regsrc=aluout dwrite=1 pcsel=pc

# 7. div - Rd, Rs, Rt   Rd <- Rs / Rt
7: op2sel=op2 aluop=div regsrc=aluout dwrite=1 pcsel=pc

# 8. rem - Rd, Rs, Rt   Rd <- Rs % Rt
8: op2sel=op2 aluop=rem regsrc=aluout dwrite=1 pcsel=pc

# 9. and - Rd, Rs, Rt   Rd <- Rs AND Rt
9: op2sel=op2 aluop=and regsrc=aluout dwrite=1 pcsel=pc

# 10. orr - Rd, Rs, Rt   Rd <- Rs OR Rt
10: op2sel=op2 aluop=or regsrc=aluout dwrite=1 pcsel=pc

# 11. eor - Rd, Rs, Rt   Rd <- Rs XOR Rt
11: op2sel=op2 aluop=xor regsrc=aluout dwrite=1 pcsel=pc

# 12. nand - Rd, Rs, Rt   Rd <- Rs NAND Rt
12: op2sel=op2 aluop=nand regsrc=aluout dwrite=1 pcsel=pc

# 13. nor - Rd, Rs, Rt   Rd <- Rs NOR Rt
13: op2sel=op2 aluop=nor regsrc=aluout dwrite=1 pcsel=pc

# 14. bic - Rd, Rs, Rt   Rd <- Rs AND !Rt
14: op2sel=op2 aluop=and regsrc=aluout negOp2=1 dwrite=1 pcsel=pc 

# 15. cmp - Rs, Rt   Rs - Rt, then set flags, result isn't saved
15: op2sel=op2 aluop=sub pcsel=pc 

# 16. cmn - Rs, Rt   Rs + Rt, then set flags, result isn't saved
16: op2sel=op2 aluop=add pcsel=pc

# 17. tst - Rs, Rt   Rs XOR Rt, then set flags, result isn't saved
17: op2sel=op2 aluop=xor pcsel=pc

# 18. teq - Rs, Rt   Rs AND Rt, then set flags, result isn't saved
18: op2sel=op2 aluop=and pcsel=pc

# 19. lsl - Rd, Rs, Rt   Rd <- Rs << Rt
19: op2sel=op2 aluop=lsl regsrc=aluout dwrite=1 pcsel=pc

# 20. lsr - Rd, Rs, Rt   Rd <- Rs >> Rt
20: op2sel=op2 aluop=lsr regsrc=aluout dwrite=1 pcsel=pc

# 21. asr - Rd, Rs, Rt   Rd <- Rs >> Rt (filled bits are the sign bit)  
21: op2sel=op2 aluop=asr regsrc=aluout dwrite=1 pcsel=pc

# 22. ror - Rd, Rs, Rt   Rd <- Rs rolled right by Rt bits  
22: op2sel=op2 aluop=ror regsrc=aluout dwrite=1 pcsel=pc

# 23. rol - Rd, Rs, Rt   Rd <- Rs rolled left by Rt bits  
23: op2sel=op2 aluop=rol regsrc=aluout dwrite=1 pcsel=pc

# 24. j - Rs/immed PC <- immed
24: pcsel=immed instrUnload=1

# 25. b - immed PC <- PC + immed
25: pcsel=pcimmed instrUnload=1

#26. bl - immed Jump to subroutine
26: pcsel=immed instrUnload=1 loadlink=1

#27. rts - Return from subroutine
27: pcsel=immed instrUnload=1 strlink=1

# For v2.2 the ldr and str isntructions below MUST ALWAYS HAVE THESE EXACT CODES

#28. str - Rs, immed  	M[immed] <- Rs
28: addrsel=immed datasel=sreg datawrite=1 pcsel=pc

#29. ldr - Rd, immed  	Rd <- M[immed]
29: addrsel=immed regsrc=operand dwrite=1 pcsel=pc

#30. ldr - Rd, [Rs] 	Rd <- M[Rs]
30: addrsel=sreg regsrc=operand dwrite=1 pcsel=pc

#31. ldr - Rd, [Rs, immed/Rt] Rd <- M[Rs + immed/Rt]
31: op2sel-op2 aluop=add addrsel=aluout regsrc=operand dwrite=1 pcsel=pc

#32. str - Rs, [Rd] 	M[Rd] <- Rs
32: addrsel=sreg datasel=dreg datawrite=1 pcsel=pc

#33. str - Rd, [Rs, immed/Rt] 	M[Rs + immed/Rt] <- Rd
33: op2sel=op2 aluop=add addrsel=aluout datasel=dreg datawrite=1 pcsel=pc